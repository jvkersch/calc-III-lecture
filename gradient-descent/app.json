[{"name": "app.py", "content": "from shiny import reactive\nfrom shiny.express import input, render, ui\nfrom shiny.ui import output_plot\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n### Objective functions ###\n\n\nclass ObjFunQuadratic:\n    X_BOUNDS = [-3.0, 3.0]\n    Y_BOUNDS = [-3.0, 3.0]\n\n    def eval_fun(self, x, y):\n        return x**2 + y**2 / 3\n\n    def eval_grad(self, x, y):\n        return [2 * x, 2 * y / 3]\n\n\nclass ObjFunHimmelblau:\n    X_BOUNDS = [-4.0, 4.0]\n    Y_BOUNDS = [-4.0, 4.0]\n\n    def eval_fun(self, x, y):\n        return (x**2 + y - 11) ** 2 + (x + y**2 - 7) ** 2\n\n    def eval_grad(self, x, y):\n        return [\n            4 * (x**2 + y - 11) * x + 2 * (x + y**2 - 7),\n            2 * (x**2 + y - 11) + 4 * (x + y**2 - 7) * y,\n        ]\n\n\nclass ObjFunLogRosenbrock:\n    X_BOUNDS = [-3.0, 3.0]\n    Y_BOUNDS = [-3.0, 3.0]\n\n    def eval_fun(self, x, y):\n        return np.log((1 - x) ** 2 + 100 * (y - x**2) ** 2 + 1)\n\n    def eval_grad(self, x, y):\n        f = np.exp(self.eval_fun(x, y))\n        g = [\n            (-2 * (1 - x) - 400 * x * (y - x**2)) / (f + 1),\n            (200 * (y - x**2)) / (f + 1),\n        ]\n        return g\n\n\nFUNCTIONS = {\n    \"Quadratic\": ObjFunQuadratic(),\n    \"Himmelblau\": ObjFunHimmelblau(),\n    \"log-Rosenbrock\": ObjFunLogRosenbrock(),\n}\n\n### Running list of trajectories that have been explored ###\n\n# Clicking the step button adds a new point to the last (active) trajectory. CLicking\n# anywhere on the plot starts a new trajectory. The _TRAJECTORIES reactive is semi-\n# private, since it needs to be set with a copy to trigger updates in the UI.\n\n_TRAJECTORIES = reactive.Value([])\n\n\ndef _update_trajectories(pts):\n    _TRAJECTORIES.set(pts.copy())  # set with copy to trigger update\n\n\ndef start_new_trajectory(pt):\n    pts = _TRAJECTORIES()\n    pts.append([pt])\n    _update_trajectories(pts)\n\n\ndef add_to_trajectory(pt):\n    pts = _TRAJECTORIES()\n    pts[-1].append(pt)\n    _update_trajectories(pts)\n\n\ndef reset_trajectories():\n    _TRAJECTORIES.set([])\n\n\ndef get_trajectories():\n    return _TRAJECTORIES()\n\n\n### UI code ###\n\nui.page_opts(title=\"Gradient descent: trajectories\", fillable=True)\n\n\ndef get_obj():\n    return FUNCTIONS[input.function()]\n\n\nwith ui.sidebar():\n    ui.input_selectize(\n        \"function\",\n        \"Function\",\n        list(FUNCTIONS),\n    )\n    ui.input_slider(\"stepsize\", \"Step size\", 0.01, 1.0, 0.1)\n    ui.input_checkbox(\"adaptive\", \"Adaptive step size\")\n    ui.input_checkbox(\"vector_field\", \"Show negative gradient\")\n    ui.input_action_button(\"step_btn\", \"Step\", class_=\"btn-success\", disabled=True)\n    ui.input_action_button(\"reset_btn\", \"Reset\")\n\n\nwith ui.layout_columns(col_widths=(12,)):\n    with ui.card():\n        output_plot(\n            \"image_2d\",\n            click=True,\n        )\n\n        with ui.hold():\n\n            @render.plot\n            def image_2d():\n                obj = get_obj()\n\n                x = np.linspace(*obj.X_BOUNDS)\n                y = np.linspace(*obj.Y_BOUNDS)\n                X, Y = np.meshgrid(x, y)\n\n                # plot objective function\n                Z = obj.eval_fun(X, Y)\n                plt.contourf(X, Y, Z, cmap=\"coolwarm\")\n                plt.colorbar()\n                plt.axis(\"equal\")\n\n                h = input.stepsize()\n\n                # plot gradient\n                if input.vector_field():\n                    xg = np.linspace(*obj.X_BOUNDS, 10)\n                    yg = np.linspace(*obj.Y_BOUNDS, 10)\n                    XG, YG = np.meshgrid(xg, yg)\n                    U, V = obj.eval_grad(XG, YG)\n\n                    plt.quiver(XG, YG, -U, -V)\n\n                # plot trajectories on top of contour map\n                for traj in get_trajectories():\n                    traj = np.asarray(traj)\n                    plt.plot(traj[:, 0], traj[:, 1], \"r-o\")\n\n                pts = get_trajectories()\n                if len(pts) > 0:\n                    current = pts[-1][-1]\n                    u, v = obj.eval_grad(*current)\n                    plt.quiver(\n                        *current,\n                        -h * u,\n                        -h * v,\n                        color=\"red\",\n                        angles=\"xy\",\n                        scale_units=\"xy\",\n                        scale=1,\n                    )\n\n                plt.tight_layout()\n\n    # with ui.card():\n\n    #     @render_plotly\n    #     def image_3d():\n    #         obj = get_obj()\n\n    #         x = np.linspace(*obj.X_BOUNDS)\n    #         y = np.linspace(*obj.Y_BOUNDS)\n    #         X, Y = np.meshgrid(x, y)\n\n    #         Z = obj.eval_fun(X, Y)\n\n    #         fig = go.Figure(data=[go.Surface(x=X, y=Y, z=Z)])\n    #         fig.update_layout(\n    #             autosize=False,\n    #             width=500,\n    #             height=500,\n    #             # margin=dict(l=65, r=50, b=65, t=90),\n    #         )\n    #         return fig\n\n    @reactive.effect\n    @reactive.event(input.image_2d_click)\n    def update_starting_point():\n        x = input.image_2d_click()[\"x\"]\n        y = input.image_2d_click()[\"y\"]\n        start_new_trajectory((x, y))\n\n        ui.update_action_button(\"step_btn\", disabled=False)\n\n    @reactive.effect\n    @reactive.event(input.reset_btn, input.adaptive)\n    def reset_btn_clicked():\n        reset_trajectories()\n\n        ui.update_action_button(\"step_btn\", disabled=True)\n\n    @reactive.effect\n    @reactive.event(input.step_btn)\n    def step_btn_clicked():\n        pts = get_trajectories()\n        obj = get_obj()\n\n        # Invariant: step button is disabled when there is no starting point,\n        # so the `pts` array is never empty\n        current = pts[-1][-1]\n\n        if input.adaptive():\n            nxt = next_step_gradient_adaptive(obj, current, 0.1)\n        else:\n            nxt = next_step_gradient_descent(obj, current, input.stepsize())\n\n        add_to_trajectory(nxt)\n\n\ndef next_step_gradient_descent(obj, start, h0):\n    grad = obj.eval_grad(*start)\n    return [start[0] - h0 * grad[0], start[1] - h0 * grad[1]]\n\n\ndef next_step_gradient_adaptive(obj, start, h0):\n    loss_current = obj.eval_fun(*start)\n    for i in range(10):\n        nxt = next_step_gradient_descent(obj, start, h0)\n        loss_nxt = obj.eval_fun(*nxt)\n        if loss_nxt < loss_current:\n            h0 *= 1.10  # slightly larger timestep\n        else:\n            h0 *= 0.70  # overshoot: shrink timestep\n            nxt = start\n            loss_nxt = loss_current\n\n    return nxt\n", "type": "text"}]