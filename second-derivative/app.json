[{"name": "app.py", "content": "from shiny import reactive\nfrom shiny.express import input, render, ui\nfrom shinywidgets import render_plotly\n\n\nimport numpy as np\nimport plotly.graph_objects as go\n\n\n### Objective functions ###\n\n\nclass ObjFunQuadratic:\n    X_BOUNDS = [-3.0, 3.0]\n    Y_BOUNDS = [-3.0, 3.0]\n\n    GRAD_TOL = 2.0\n\n    def eval_fun(self, x, y):\n        return x**2 + y**2 / 3\n\n    def eval_grad(self, x, y):\n        return np.asarray([2 * x, 2 * y / 3])\n\n    def eval_hessian(self, x, y):\n        return np.asarray([[2, 0], [0, 2 / 3]])\n\n\nclass ObjFunTwoMinima:\n    X_BOUNDS = [-2.0, 2.0]\n    Y_BOUNDS = [-1.0, 1.0]\n\n    GRAD_TOL = 2.0\n\n    def eval_fun(self, x, y):\n        return x**4 - 4 * x**2 + y**2\n\n    def eval_grad(self, x, y):\n        return np.asarray(\n            [\n                4 * x**3 - 8 * x,\n                2 * y,\n            ]\n        )\n\n    def eval_hessian(self, x, y):\n        return np.asarray([[12 * x**2 - 8, 0], [0, 2]])\n\n\nclass ObjFunHimmelblau:\n    X_BOUNDS = [-4.0, 4.0]\n    Y_BOUNDS = [-4.0, 4.0]\n\n    GRAD_TOL = 15.0\n\n    def eval_fun(self, x, y):\n        return (x**2 + y - 11) ** 2 + (x + y**2 - 7) ** 2\n\n    def eval_grad(self, x, y):\n        return np.asarray(\n            [\n                4 * (x**2 + y - 11) * x + 2 * (x + y**2 - 7),\n                2 * (x**2 + y - 11) + 4 * (x + y**2 - 7) * y,\n            ]\n        )\n\n    def eval_hessian(self, x, y):\n        return np.asarray(\n            [\n                [4 * (x**2 + y - 11) + 8 * x**2 + 2, 4 * x + 4 * y],\n                [4 * x + 4 * y, 4 * (x + y**2 - 7) + 8 * y**2 + 2],\n            ]\n        )\n\n\nFUNCTIONS = {\n    \"Quadratic\": ObjFunQuadratic(),\n    \"Two minima\": ObjFunTwoMinima(),\n    \"Himmelblau\": ObjFunHimmelblau(),\n}\n\n### Placeholder for mouse hover over coordinates ###\n\nhover_reactive = reactive.value()\n\n\ndef on_point_hover(_, points, __):\n    coords = points.xs[0], points.ys[0]\n    hover_reactive.set(coords)\n\n\n### UI ###\n\nui.page_opts(title=\"Minima, maxima, saddle points\", fillable=True)\n\nui.head_content(\n    ui.tags.script(src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\")\n)\n\n\ndef _safe_round(x):\n    return \"-\" if x is None else round(x, 2)\n\n\ndef _make_gradient(dx=None, dy=None):\n    return rf\"\"\"Gradient:\n\\begin{{bmatrix}}\n    {_safe_round(dx)} & {_safe_round(dy)}\n\\end{{bmatrix}}\n\"\"\"\n\n\ndef _make_hessian(dxx=None, dxy=None, dyy=None):\n    return rf\"\"\"Hessian:\n\\begin{{bmatrix}}\n    {_safe_round(dxx)} & {_safe_round(dxy)} \\\\\\\\\n    {_safe_round(dxy)} & {_safe_round(dyy)}\n\\end{{bmatrix}}\n\"\"\"\n\n\ndef _wrap_mathjax(latex):\n    return ui.TagList(\n        ui.HTML(latex), ui.tags.script(\"window.MathJax && MathJax.typeset();\")\n    )\n\n\ndef get_obj():\n    return FUNCTIONS[input.function()]\n\n\nwith ui.sidebar():\n    ui.input_selectize(\n        \"function\",\n        \"Function\",\n        list(FUNCTIONS),\n    )\n\n    @render.ui\n    def show_gradient():\n        obj = get_obj()\n        coords = hover_reactive.get()\n        u, v = obj.eval_grad(*coords)\n        latex = _make_gradient(u, v)\n        return _wrap_mathjax(latex)\n\n    @render.ui\n    def show_hessian():\n        obj = get_obj()\n        coords = hover_reactive.get()\n        h = obj.eval_hessian(*coords)\n        latex = _make_hessian(h[0, 0], h[0, 1], h[1, 1])\n        return _wrap_mathjax(latex)\n\n    @render.ui\n    def show_classification():\n        obj = get_obj()\n        coords = hover_reactive.get()\n        g = obj.eval_grad(*coords)\n        h = obj.eval_hessian(*coords)\n        d = np.linalg.det(h)\n\n        if np.linalg.norm(g) > obj.GRAD_TOL:\n            cls = \"-\"\n        else:\n            if d > 0:\n                cls = \"minimum\" if h[0, 0] > 0 else \"maximum\"\n            elif d < 0:\n                cls = \"saddle\"\n\n        return f\"Classification: {cls}\"\n\n\nwith ui.card():\n\n    @render_plotly\n    def image_3d():\n        obj = get_obj()\n\n        x = np.linspace(*obj.X_BOUNDS)\n        y = np.linspace(*obj.Y_BOUNDS)\n        X, Y = np.meshgrid(x, y)\n        Z = obj.eval_fun(X, Y)\n\n        fig = go.Figure(\n            data=[\n                go.Surface(\n                    x=X,\n                    y=Y,\n                    z=Z,\n                    hoverinfo=\"none\",\n                )\n            ]\n        )\n        fig.update_layout(\n            autosize=False,\n            width=500,\n            height=500,\n        )\n\n        w = go.FigureWidget(fig)\n        w.data[0].on_hover(on_point_hover)\n\n        return w\n", "type": "text"}]